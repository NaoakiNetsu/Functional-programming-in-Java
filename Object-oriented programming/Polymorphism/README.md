## ポリモーフィズムについて

とりあえず、継承、オーバーライド、ポリモーフィズムについて適当にまとめる。
* 継承  
子クラスは親クラスのフィールド・メソッドを受け継ぐことができる（staticなものは除く）。  
→すなわち、親のクラスの機能を持ったまま、拡張することを「**継承**」と呼ぶ。

 * オーバーライド  
子クラスが親クラスと同じ形（シグネチャ）のメソッドを再定義することを「**オーバーライド**」と呼ぶ。  
※シグネチャ：メソッド名と引数（型、数、順序）  
→共通部分を親クラスに定義しておき、必要に応じて、差分があれば子クラスでオーバーライドできる。

* ポリモーフィズム  
子クラスのオブジェクトは親クラスの型と**代入互換性がある**という性質があるので、親クラスの型で子クラスのインスタンスを宣言して扱うことができる。  
→同じ命令「逃げろ」「走れ」でも、子クラス毎に振る舞いが異なる。  
→命令する側が違いを意識しなくても、異なる動きをしてくれる。  
つまり、共通のメソッド呼び出しで、対象とするオブジェクトの種類に応じてまったく異なるさまざまな処理を実行可能な性質を「**ポリモーフィズム（多態性）**」と呼ぶ。

具体的な実装例を示そうと思う。  
※以下の資料から持ってきた。  
[現場で役立つシステム設計の原則をまとめたときの資料](https://github.com/NaoakiNetsu/In-house-study/blob/master/Systems%20Architecture/%E7%8F%BE%E5%A0%B4%E3%81%A7%E5%BD%B9%E7%AB%8B%E3%81%A4%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E3%81%AE%E5%8E%9F%E5%89%87/README.md)

親クラスFeeと子クラスAdultFeeとChildFeeを定義して、それらのオブジェクトを扱うクラスを作成する。  

```java
// 大人クラスと子供クラスが継承するインターフェース
interface Fee {
    // 抽象メソッドとしてfeeとlabelを用意。実装は各子クラス（今回の場合は大人クラスと子供クラス）で行われる
    Yen fee();  // Yen型（お金）オブジェクトはJavaの標準オブジェクトではなく、日本円を扱う独自オブジェクトの想定
    String label();
}

// 大人クラス
class AdultFee implements Fee {
    // オーバーライド
    @Override
    Yen fee() {
        return new Yen(100);
    }
    
    @Override
    String label() {
         return "大人";
    }
}

// 子供クラス
class ChildFee implements Fee {
    // オーバーライド
    @Override
    Yen fee() {
        return new Yen(50);
    }
    
    @Override
    String label() {
         return "子供";
    }
}
```

このように実装しておくことで、Fee型を使う側は以下のように書ける。

```java
class Charge {
    Fee fee;
    
    Charge(Fee fee) {
        // コンストラクタに渡されたFee型のオブジェクトを代入
        this.fee = fee;
    }
    
    Yen yen() {
         return fee.yen();
    }
}
```

Chargeクラスのオブジェクトを生成する時に、コンストラクタにFee型のどのクラスのオブジェクトを渡すかによって、Chargeクラスの振る舞いは変わる。コンストラクタに渡すオブジェクトがAdultFee型であれば大人料金を計算し、ChildFee型であれば子供料金を計算する。
この記述をプログラムに起こすと以下のようになる。

```java
// Fee型でAdultFeeオブジェクトを生成
// これが所謂「代入互換性」であり、子クラスのオブジェクトは親クラスの型で生成することができる
Fee fee = new AdultFee();

// AdultFeeオブジェクトを引数に渡してchargeオブジェクトを生成
Charge charge = new charge(fee);
    
// ここで呼ばれるyenメソッドはAdultFeeクラスで定義されたyenメソッド
Yen yen = charge.yen();

// 100が出力される
System.out.println(yen);
```

以上より、開発者が区分の違いを意識せずとも、返却される金額はchargeオブジェクト生成時に渡されるオブジェクトによって決められることがわかる。
childFeeインスタンスを引数に渡せば結果は50が出力されるのである。
ポリモーフィズムという性質によって、同じ親クラスの型で生成されたインスタンスの同じメソッドを呼んだ際に、子インスタンス毎に振る舞いが変えることができる。

参考： [いまさらですが、職業Javaプログラマーなら理解しておいてほしい「継承」の意味について](http://d.hatena.ne.jp/ryoasai/20110623/1308841453)
