## Table of Contents
<!-- TOC -->

- [現場で役立つシステム設計の原則](#現場で役立つシステム設計の原則)
        - [前提条件（本書籍の目的）](#前提条件本書籍の目的)
    - [Chapter 1：小さくまとめてわかりやすくする](#chapter-1小さくまとめてわかりやすくする)
        - [ドメインオブジェクト_p. 26付近](#ドメインオブジェクト_p-26付近)
        - [値オブジェクト_p. 32付近](#値オブジェクト_p-32付近)
        - [コレクションオブジェクト_p. 41付近](#コレクションオブジェクト_p-41付近)
    - [Chapter 2：場合分けのロジックを整理する](#chapter-2場合分けのロジックを整理する)
        - [分岐処理の記述を簡単にする_p. 49付近](#分岐処理の記述を簡単にする_p-49付近)
            - [判断や処理のロジックをメソッドに独立](#判断や処理のロジックをメソッドに独立)
            - [else句をなくして条件分岐を単純に](#else句をなくして条件分岐を単純に)
        - [そもそも分岐処理を記述しない_p. 53付近](#そもそも分岐処理を記述しない_p-53付近)
            - [①区分ごとのロジックを別クラスに切り出す](#①区分ごとのロジックを別クラスに切り出す)
            - [②区分ごとのクラスを同じ「型」として扱う](#②区分ごとのクラスを同じ型として扱う)
            - [③列挙型「enum」を用いた区分オブジェクトの導入](#③列挙型「enum」を用いた区分オブジェクトの導入)
        - [区分ごとの業務ロジックを区分オブジェクトで分析し整理する_p. 61付近](#区分ごとの業務ロジックを区分オブジェクトで分析し整理する_p. 61付近)
        

<!-- /TOC -->

---

# 現場で役立つシステム設計の原則

個人的にいいなと思ったり勉強になった部分だけピックアップしてまとめる。

※一応説明不足だなと感じた部分は補足しているが、それでもクラス、メソッド、コンストラクタ、継承くらいの基礎知識はないと読み進めるのは難しいと感じた。

### 前提条件（本書籍の目的）
オブジェクト指向の考え方を用いてソフトウェアを設計できるようになること。

---

## Chapter 1：小さくまとめてわかりやすくする
### ドメインオブジェクト_p. 26付近
業務で使われる用語に合わせて、その用語の関心事に直接対応するクラス、**ドメインオブジェクト**を用意することが、業務アプリケーションの変更を容易にするオブジェクト指向的な設計のアプローチである。

ドメインオブジェクト毎に独立させておくことで、**変更の対象と影響範囲を限定することができ**、将来の変更も容易となる。

---

### 値オブジェクト_p. 32付近
業務アプリケーションをオブジェクト指向で設計する場合には、業務で扱うデータの種類毎に専用のクラス、**値オブジェクト(Value Object)** を用意する。

■値オブジェクトの例

値オブジェクト|内容
:--|:--
Quantity|数量（と単位）
Amount|金額
Money|金額と通貨
Days|日付
Hours|時間
Telephone|電話番号
Email|メールアドレス
Url|URL

など。

専用の型を持つことで業務的に不適切な値が混入するバグを防ぐことができる。
通常のintやStringは業務に関する関心事ではないが、QuantityやMoneyは業務関心そのものを表現するので、**業務の理解とプログラムの設計を直接的に関連付けることができ**、整理された変更が楽で安全なプログラムを作ることができる。

値オブジェクトの具体的なルールは以下の通り。
* インスタンス変数はコンストラクタでオブジェクトの生成時に設定する。
* インスタンス変数を変更するメソッド(setter)を作らない。
* 別の値が必要であれば、別のインスタンスを作る

このような設計のやり方を**完全コンストラクタ**と呼ぶ。

```java
// 完全コンストラクタで設計されたMoneyオブジェクトを使う。
Money basePrice = new Money(3000);
Money discounted = basePrise.minus(1000); // 金額を割引したい場合、割引された金額を保持する新しいMoneyオブジェクトを作る。
// minus()メソッドは別のMoneyオブジェクトを作成して返す

Money option = new Money(1000) // 別の値が必要になったら新しいMoneyオブジェクトを作成する
```

★参考文献  
[値オブジェクトとコレクションオブジェクト](http://blog.sojiro.me/blog/2017/08/25/value-object-and-collection-object/)

↑のブログに記載されていた「これらはサーバーリクエストの口でバリデーションを通るものの、その後の値がアプリケーションコード内で保証されないため非常に不安定だった。」はまったくもってその通りだと思った。ダブルチェックしてサーバ側の処理に入ってきても、結局不正な値になる可能性はあるので。

---

### コレクションオブジェクト_p. 41付近

List型、Map型、Set型などのコレクション型のオブジェクトは業務データを扱うために非常によく使われる(e.g., 利用者一覧, 職員一覧, 売上一覧)。これらのデータを業務ロジックは分岐処理やループ処理が入れ子になったり複雑になりがちである。

そこで値オブジェクトと同じような考え方で、コレクション型のインスタンス変数を1つだけ持ち、そのデータを操作するロジックだけを集めたクラス、**コレクションオブジェクト**あるいは**ファーストクラスコレクション**を用意する。

```java
// 利用者一覧の専用クラス
class Users {
    List<User> users;
    
    void add(User user) { // something } 
    void removeIfExist(User user) { // something }

    int count() { // something }
    
    Users importantUsers() { // something }
```

コレクションオブジェクトは**業務の関心事そのもの**で、値オブジェクト同様、業務の関心事とクラスを1対1で対応させて、**プログラムの変更箇所を特定しやすくし、変更による影響の範囲を限定する**ための工夫である。

※個人的にはしっかりとしたコレクションオブジェクトを用意するのは困難なように思うが、用意したほうがいいことは確実だろう。

---
## Chapter 2：場合分けのロジックを整理する

### 分岐処理の記述を簡単にする_p. 49付近

#### 判断や処理のロジックをメソッドに独立

以下は顧客の区分が子供"child"だった場合、金額を半額にするという分岐処理である。
```java
// 悪い例
if (customerType.equals("child"))
    fee = baseFee * 0.5;
```

↑のプログラムから判断や処理をメソッド化すると、

```java
// 良い例
if (isChild())
    fee = childFee() ;
    
// 判断部分のメソッド
private Boolean isChild () {
    return customerType.equals("child");
}

// 処理部分のメソッド
private int childFee() {
    retrun baseFee * 0.5;
}
```

と書ける。こうすることで元々のif分はメソッドを呼び出すだけになり、メソッド名を見るだけで**何をやっているかが明確となる**。  
また、判断や処理の方法・基準が変わったとしても、メソッドだけを修正すればよいので、クラス内の色々なところで同じような判断、処理を行っている場合でも修正が容易である。

---

#### else句をなくして条件分岐を単純に

以下は、顧客を「子供」「大人」「シニア」の区分で別料金にするロジックをelse句を使って書いた例である。

```java
// 悪い例

// Yen型(お金)オブジェクトを返却するメソッド
Yen fee() {
    Yen result;
    
    if (isChild()) {
        result = childFee();
    } else if (isSenior()) {
        result = seniorFee();
    } else {
        result = adultFee();
    }
    
    return result
}
```

↑の例からローカル変数の定義とローカル変数への代入処理を省くと、

```java
// Yen型(お金)オブジェクトを返却するメソッド
Yen fee() {
    if (isChild()) {
        return childFee();
    } else if (isSenior()) {
        return seniorFee();
    } else {
        return adultFee();
    }
}
```

return文で処理を抜けるのでif文以降の処理を書かずに済み、コードが少しシンプルになった。これが**早期リターン**と呼ばれる記述方法である。

早期リターンを使うのであれば、そもそもelse文にする必要はない（nullが返却されることがない）ので、

```java
// 良い例

// Yen型(お金)オブジェクトを返却するメソッド
Yen fee() {
    if (isChild()) return childFee(); // 分岐後の処理が1行だけの場合{}は省略できる。これはjava 7以前からずっとだと思う。
    if (isSenior()) return seniorFee();
    return adultFee();
}
```

かなりすっきりしたコードになった。

else句を使わずに早期リターンするこの書き方は**ガード節**と呼ばれ、有名なリファクタリング手法である。

---

### そもそも分岐処理を記述しない_p. 53付近

※書籍中ではステップのような感じでは書かれていないが、個人的にはそのほうがしっくりくるので、ここは真面目に書籍を読んでもらったほうがいいかもしれない。

※ただし、書籍よりもわかりやすく要点をまとめたつもり。書籍はポリモーフィズムなどのJava(だけでなく、Java以外のオブジェクト指向言語)が持つ重要かつ単純ではない機能について理解している前提で書かれているように見受けられてたため、そこは補填している。

#### ①区分ごとのロジックを別クラスに切り出す

↑の顧客の区分ごとの料金計算をメソッドに独立して何をやっているかを明確にしていたが、さらにロジックごとにクラスを作ることで独立性を高めることができる。  
つまり顧客区分ごとに「大人」クラス、「子供」クラス、「シニア」クラスを作る。

```java
// 大人クラス
class AdultFee {
    Yen fee() {
        return new Yen(100);
    }
    
    String label() {
         return "大人";
    }
}

// 子供クラス
class ChildFee {
    Yen fee() {
        return new Yen(50);
    }
    
    String label() {
         return "子供";
    }
}

// シニアクラス
class SeniorFee {
    Yen fee() {
        return new Yen(80);
    }
    
    String label() {
         return "シニア";
    }
}
```

#### ②区分ごとのクラスを同じ「型」として扱う

クラスを使う側がAdultFee型とChildFee型を意識して使う分ける必要がないように共通のインターフェースを用意して、同じ型で扱えるようにする。  

※子クラスのオブジェクトは親クラスの型と**代入互換性**があるため、それを利用する。

```java
// 大人クラスと子供クラスが継承するインターフェース
interface Fee {
    // 抽象メソッドとしてfeeとlabelを用意。実装は各子クラス（今回の場合は大人クラスと子供クラス）で行われる
    Yen fee();
    String label();
}

// 大人クラス
class AdultFee implements Fee {
    // オーバーライド
    @Override
    Yen fee() {
        return new Yen(100);
    }
    
    @Override
    String label() {
         return "大人";
    }
}

// 子供クラス
class ChildFee implements Fee {
    // オーバーライド
    @Override
    Yen fee() {
        return new Yen(50);
    }
    
    @Override
    String label() {
         return "子供";
    }
}
```

このように実装しておくことで、Fee型を使う側は以下のように書ける。

```java
class Charge {
    Fee fee;
    
    Charge(Fee fee) {
        // コンストラクタに渡されたFee型のオブジェクトを代入
        this.fee = fee;
    }
    
    Yen yen() {
         return fee.yen();
    }
}
```

書籍では、「Chargeクラスのオブジェクトを生成する時に、コンストラクタにFee型のどのクラスのオブジェクトを渡すかによって、Chargeクラスの振る舞いは変わります。コンストラクタに渡すオブジェクトがAdultFee型であれば大人料金を計算します。ChildFee型であれば子供料金を計算します。」と書いてあるが、この記述をプログラムに起こすと以下のようになる。

```java
// Fee型でAdultFeeオブジェクトを生成
// これが所謂「代入互換性」であり、子クラスのオブジェクトは親クラスの型で生成することができる
Fee fee = new AdultFee();

// AdultFeeオブジェクトを引数に渡してchargeオブジェクトを生成
Charge charge = new charge(fee);
    
// ここで呼ばれるyenメソッドはAdultFeeクラスで定義されたyenメソッド
Yen yen = charge.yen();

// 100が出力される
System.out.println(yen);
```

以上より、開発者が区分の違いを意識せずとも、返却される金額はchargeオブジェクト生成時に渡されるオブジェクトによって決められることがわかる。

※そもそも代入互換性や継承、オーバーライド、ポリモーフィズムについて理解が足りない場合は「[スッキリわかるJava入門](https://www.amazon.co.jp/%E3%82%B9%E3%83%83%E3%82%AD%E3%83%AA%E3%82%8F%E3%81%8B%E3%82%8BJava%E5%85%A5%E9%96%80-%E7%AC%AC2%E7%89%88-%E3%82%B9%E3%83%83%E3%82%AD%E3%83%AA%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA-%E4%B8%AD%E5%B1%B1-%E6%B8%85%E5%96%AC/dp/484433638X/ref=asc_df_484433638X/?tag=jpgo-22&linkCode=df0&hvadid=295704876452&hvpos=1o1&hvnetw=g&hvrand=17080245801697300971&hvpone=&hvptwo=&hvqmt=&hvdev=c&hvdvcmdl=&hvlocint=&hvlocphy=9053345&hvtargid=pla-526397172864&psc=1&th=1&psc=1)」の13章あたりを読むのが個人的にはおすすめ。あとは「[達人プログラマーを目指して](https://ryoasai.hatenadiary.org/)」というブログも参考になる記事がたくさんある。

#### ③列挙型「enum」を用いた区分オブジェクトの導入
①②を通して既に分岐処理を記述しないで記載できているのだが、より一覧性をあげるために列挙型「enum」を用いる。

さっそく書籍と同様、簡単に列挙型の使い方を説明すると、

```java
// 料金区分を定義する
enum FeeType {
    adult,
    child,
    sinior
}

// 区分を使う側
FeeType fee = FeeType.adult;
        
System.out.println(fee); // adultと表示される
```

実は列挙型enumはクラスなので、メソッドやコンストラクタも定義できる。

```java
// Globeを定義する ※別に世代ではないけど前に調べたときに参考にしたサイトの名残。そのサイトは既に存在しないが。
enum Globe {
    MARC("酒井龍一"),
    KEIKO("山田桂子"),
    TK("小室哲哉");
 
    // フィールド変数
    private String label;
 
    // コンストラクタ
    // ※コンストラクタのアクセス修飾子はprivateのみ使用可
    // 他クラスからインスタンスを生成させないシングルトンパターンな作り
    // そもそもenumはシングルトンが保証されているから明示的にprivate修飾子を書く必要はなかった気がする
    private Globe(String label) {
        this.label = label;
    }
 
    // 名称取得メソッド
    public String getLabel() {
        return this.label;
    }
}

// 区分を使う側
system.out.println(Globe.TK.getLabel()); // 小室哲哉と表示される
```

Globe.TKが呼ばれた時点で、列挙定数TKの名称"小室哲哉"を引数にしてコンストラクタが呼ばれフィールド定数に"小室哲哉"が定義されてインスタンス化される。あとはそのインスタンスからgetLabel()メソッドを呼んでやればフィールド定数の"小室哲哉"がリターンされる。

したがって、②のポリモーフィズムの考え方にここまで説明した列挙型enumを組み合わせると、

```java
// 料金区分を定義す
enum FeeType {
    adult( new AdultFee() ), // AdultFeeインスタンスをコンストラクタに渡すように定義
    child( new ChildFee() ),
    sinior( new SiniorFee() )

    private Fee fee;
    
    private FeeType(Fee fee) { // 上の定義にもあるようにFee型のインスタンスが渡されるようなコンストラクタにする
        this.fee = fee;
    }
    
    public Yen yen() {
        // 各料金区分クラスで定義されたyenメソッドを実行した結果を返却
        return fee.yen();
    }
    
    public String getLabel() {
        // 各料金区分クラスで定義されたlabelメソッドを実行した結果を返却
        return fee.label();
    }
}

// 料金を計算するためのメソッドを定義
Yen feeFor(String feeTypeName) {
    // 引数として渡されてきた値で列挙型FeeTypeから定数を呼び出す
    FeeType feeType = FeeType.valueOf(feeTypeName);
    
    // 上で生成されたインスタンスからyenメソッドを呼び出して返却
    return feeType.yen();
}

// feeForメソッドを呼び出す側
system.out.println(feeFor("adult")); // 100が出力される
```

使う側はfeeForメソッドの引数に料金区分と同じ文字列を渡すだけでそれぞれの金額を取得することができる。

料金区分にはどんなものがあるのか列挙型FeeTypeの定義を見れば一発で理解でき、それぞれの区分のロジックはそれぞれのクラスで定義されており、非常に一覧性とメンテンナンス性が高いプログラムになっていると考えることができる。

以上のように、列挙型enumを使って、区分ごとのロジックをわかりやすく整理する方法を**区分オブジェクト**と呼ぶ（らしいが、方法がオブジェクトってのは違和感ありまくり）。
単なる定数ではなくロジックを含んだオブジェクトとして定義することが肝。

### 区分ごとの業務ロジックを区分オブジェクトで分析し整理する_p. 61付近
