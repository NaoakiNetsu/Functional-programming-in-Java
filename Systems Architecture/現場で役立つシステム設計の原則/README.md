## Table of Contents
<!-- TOC -->

- [現場で役立つシステム設計の原則](#現場で役立つシステム設計の原則)
        - [前提条件（本書籍の目的）](#前提条件本書籍の目的)
    - [Chapter 1：小さくまとめてわかりやすくする](#chapter-1小さくまとめてわかりやすくする)
        - [ドメインオブジェクト_p. 26付近](#ドメインオブジェクト_p-26付近)
        - [値オブジェクト_p. 32付近](#値オブジェクト_p-32付近)
        - [コレクションオブジェクト_p. 41付近](#コレクションオブジェクト_p-41付近)
    - [Chapter 2：場合分けのロジックを整理する](#chapter-2場合分けのロジックを整理する)
        - [分岐処理の記述を簡単にする_p. 49付近](#分岐処理の記述を簡単にする_p-49付近)
            - [判断や処理のロジックをメソッドに独立](#判断や処理のロジックをメソッドに独立)
            - [else句をなくして条件分岐を単純に](#else句をなくして条件分岐を単純に)

<!-- /TOC -->

---

# 現場で役立つシステム設計の原則

個人的にいいなと思ったり勉強になった部分だけピックアップしてまとめる。

### 前提条件（本書籍の目的）
オブジェクト指向の考え方を用いてソフトウェアを設計できるようになること。

---

## Chapter 1：小さくまとめてわかりやすくする
### ドメインオブジェクト_p. 26付近
業務で使われる用語に合わせて、その用語の関心事に直接対応するクラス、**ドメインオブジェクト**を用意することが、業務アプリケーションの変更を容易にするオブジェクト指向的な設計のアプローチである。

ドメインオブジェクト毎に独立させておくことで、**変更の対象と影響範囲を限定することができ**、将来の変更も容易となる。

---

### 値オブジェクト_p. 32付近
業務アプリケーションをオブジェクト指向で設計する場合には、業務で扱うデータの種類毎に専用のクラス、**値オブジェクト(Value Object)** を用意する。

■値オブジェクトの例

値オブジェクト|内容
:--|:--
Quantity|数量（と単位）
Amount|金額
Money|金額と通貨
Days|日付
Hours|時間
Telephone|電話番号
Email|メールアドレス
Url|URL

など。

専用の型を持つことで業務的に不適切な値が混入するバグを防ぐことができる。
通常のintやStringは業務に関する関心事ではないが、QuantityやMoneyは業務関心そのものを表現するので、**業務の理解とプログラムの設計を直接的に関連付けることができ**、整理された変更が楽で安全なプログラムを作ることができる。

値オブジェクトの具体的なルールは以下の通り。
* インスタンス変数はコンストラクタでオブジェクトの生成時に設定する。
* インスタンス変数を変更するメソッド(setter)を作らない。
* 別の値が必要であれば、別のインスタンスを作る

このような設計のやり方を**完全コンストラクタ**と呼ぶ。

```java
// 完全コンストラクタで設計されたMoneyオブジェクトを使う。
Money basePrice = new Money(3000);
Money discounted = basePrise.minus(1000); // 金額を割引したい場合、割引された金額を保持する新しいMoneyオブジェクトを作る。
// minus()メソッドは別のMoneyオブジェクトを作成して返す

Money option = new Money(1000) // 別の値が必要になったら新しいMoneyオブジェクトを作成する
```

★参考文献  
[値オブジェクトとコレクションオブジェクト](http://blog.sojiro.me/blog/2017/08/25/value-object-and-collection-object/)

↑のブログに記載されていた「これらはサーバーリクエストの口でバリデーションを通るものの、その後の値がアプリケーションコード内で保証されないため非常に不安定だった。」はまったくもってその通りだと思った。ダブルチェックしてサーバ側の処理に入ってきても、結局不正な値になる可能性はあるので。

---

### コレクションオブジェクト_p. 41付近

List型、Map型、Set型などのコレクション型のオブジェクトは業務データを扱うために非常によく使われる(e.g., 利用者一覧, 職員一覧, 売上一覧)。これらのデータを業務ロジックは分岐処理やループ処理が入れ子になったり複雑になりがちである。

そこで値オブジェクトと同じような考え方で、コレクション型のインスタンス変数を1つだけ持ち、そのデータを操作するロジックだけを集めたクラス、**コレクションオブジェクト**あるいは**ファーストクラスコレクション**を用意する。

```java
// 利用者一覧の専用クラス
class Users {
    List<User> users;
    
    void add(User user) { // something } 
    void removeIfExist(User user) { // something }

    int count() { // something }
    
    Users importantUsers() { // something }
```

コレクションオブジェクトは**業務の関心事そのもの**で、値オブジェクト同様、業務の関心事とクラスを1対1で対応させて、**プログラムの変更箇所を特定しやすくし、変更による影響の範囲を限定する**ための工夫である。

※個人的にはしっかりとしたコレクションオブジェクトを用意するのは困難なように思うが、用意したほうがいいことは確実だろう。

---
## Chapter 2：場合分けのロジックを整理する

### 分岐処理の記述を簡単にする_p. 49付近

#### 判断や処理のロジックをメソッドに独立

以下は顧客タイプが子供"child"だった場合、金額を半額にするという分岐処理である。
```java
// 悪い例
if (customerType.equals("child"))
    fee = baseFee * 0.5;
```

↑のプログラムから判断や処理をメソッド化すると、

```java
// 良い例
if (isChild())
    fee = childFee() ;
    
// 判断部分のメソッド
private Boolean isChild () {
    return customerType.equals("child");
}

// 処理部分のメソッド
private int childFee() {
    retrun baseFee * 0.5;
}
```

と書ける。こうすることで元々のif分はメソッドを呼び出すだけになり、メソッド名を見るだけで**何をやっているかが明確となる**。  
また、判断や処理の方法・基準が変わったとしても、メソッドだけを修正すればよいので、クラス内の色々なところで同じような判断、処理を行っている場合でも修正が容易である。

---

#### else句をなくして条件分岐を単純に

以下は、「子供」「大人」「シニア」で別料金にするロジックをelse句を使って書いた例である。

```java
// 悪い例

// Yen型(お金)オブジェクトを返却するメソッド
Yen fee() {
    Yen result;
    
    if (isChild()) {
        result = childFee();
    } else if (isSenior()) {
        result = seniorFee();
    } else {
        result = adultFee();
    }
    
    return result
}
```

↑の例からローカル変数の定義とローカル変数への代入処理を省くと、

```java
// Yen型(お金)オブジェクトを返却するメソッド
Yen fee() {
    if (isChild()) {
        return childFee();
    } else if (isSenior()) {
        return seniorFee();
    } else {
        return adultFee();
    }
}
```

return文で処理を抜けるのでif文以降の処理を書かずに済み、コードが少しシンプルになった。これが**早期リターン**と呼ばれる記述方法である。

早期リターンを使うのであれば、そもそもelse文にする必要はない（nullが返却されることがない）ので、

```java
// 良い例

// Yen型(お金)オブジェクトを返却するメソッド
Yen fee() {
    if (isChild()) return childFee(); // 分岐後の処理が1行だけの場合{}は省略できる。これはjava 7以前からずっとだと思う。
    if (isSenior()) return seniorFee();
    return adultFee();
}
```

かなりすっきりしたコードになった。

else句を使わずに早期リターンするこの書き方は**ガード節**と呼ばれ、有名なリファクタリング手法である。

---

### そもそも分岐処理を記述しない_p. 53付近

※書籍中ではステップのような感じでは書かれていないが、個人的にはそのほうがしっくりくるので、ここは真面目に書籍を読んでもらったほうがいいかもしれない。

#### ①区分ごとのロジックを別クラスに切り出す
